---
title: "The structure and interaction of silica in plant cell walls: Data analysis report"
author: "Felipe Beltran"
date: "6/16/2021"
output:
    rmdformats::downcute
---

# Introduction

In this document we will save all data manipulation and analysis related to the infrared spectra from the project: **The structure and interaction of silica in plant cell walls**

# Loading data into `R`

```{r}
names <- list.files(pattern = '.CSV')
spectra.list <- lapply(names, read.csv, header = F)
wavenumbers <- unlist(spectra.list[[1]][1])
spectra.list2 <- lapply(spectra.list, '[', 2)
spectra.df <- as.data.frame(t(as.data.frame(spectra.list2)))
rownames(spectra.df) <- names
colnames(spectra.df) <- wavenumbers
# gsub('.{6}$', '', names)
```

# Plotting intial data

```{r}

names2 <- gsub('.{4}$', '', rownames(spectra.df))
names2[292:318] <- gsub('.{41}$', '', rownames(spectra.df)[292:318])
rownames(spectra.df) <- names
cols <- factor(gsub('.{2}$', '', names2))
for(i in  1:length(rownames(spectra.df))){
  
  plot(wavenumbers,
    spectra.df[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(4000, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra full range',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```


# range selection

```{r}
colnames(spectra.df)[c(1,676)]
```
```{r}
range1 <- spectra.df[,c(1:676)]
wavenumbers1 <- wavenumbers[c(1:676)]
for(i in  1:length(rownames(range1))){
  
  plot(wavenumbers1,
    range1[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra - ROI',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')

```
# mean spectra calculation

First, we create a vector to tell R which samples to look for:

```{r}
search.vector <- unique(unlist(cols))
```
Now we search for each triad of samples:

```{r}
index <- list(106)

for (i in 1:106){
  
  index[[i]] <- which(grepl(paste0('(?=.*',as.character(search.vector[i]),')'),
                       rownames(spectra.df),
                       perl=T
                       )
                 )
}
```

Now we can calculate the means:

```{r}
mean <- matrix(ncol= ncol(range1),
               nrow = nrow(range1)/3)
# mean <- as.data.frame(mean)

colnames(mean) <- colnames(range1)
rownames(mean) <- search.vector

for(j in 1:length(colnames(range1))){
  
for(i in 1:length(rownames(mean))){

mean[i,j] <- mean(c(range1[index[[i]][1],j],
                    range1[index[[i]][2],j],
                    range1[index[[i]][3],j]
                      ) )
}
}
mean <- as.data.frame(mean)
```

Now we can plot the means:

```{r}

cols.means <- as.factor(search.vector)
for(i in  1:length(rownames(mean))){
  
  plot(wavenumbers1,
    mean[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols.means[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'averaged spectra',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```



# baseline correction

```{r}
library(hyperSpec)

spc <- new('hyperSpec',
           spc= mean, 
           wavelength = wavenumbers1)

bend <- 0.1 * wl.eval(spc,
                      function (x) x^6+x^5+x^4+x^3+x^2,
                      normalize.wl = normalize01)

bl <- spc.rubberband(spc+bend, noise = 1e-4, df = 20)-bend
suma <- spc+bend
spc3 <- spc - bl

plot(spc, wl.reverse = TRUE)
plot(bl, add=TRUE, col=2,wl.reverse = TRUE)
plot(suma,wl.reverse = TRUE)
plot(bend, add=TRUE, col=2,wl.reverse = TRUE)
plot(spc3,wl.reverse = TRUE)

corrected1  <- as.data.frame(spc3[1:106])
corrected <- as.data.frame(corrected1[,1])
```

```{r ,echo = FALSE}
# par(mfrow = c(2,2))
# 
# for(i in  1:length(rownames(spectra.df))){
#   
#   plot(wavenumbers,
#     spectra.df[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(4000, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra full range',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(range1))){
#   
#   plot(wavenumbers1,
#     range1[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra - ROI',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     mean[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'averaged spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     corrected[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.1),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'corrected spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')

```


# metadata


First, we load the metadata table, created from the data table 'Datos_para_colombia.xlsx':

```{r}
library(readxl)
metadata <- read_excel("metadata.xlsx")
which(is.na(metadata$sample))
```


```{r}
metadata <- metadata[-c(17),]
which(is.na(metadata$sample))
```

## matching samples that have metadata with samples with spectra

```{r}

positions <- vector('list', 87) # the same sizeas metadata$sample

for (i in 1:87){
  
positions[[i]] <- which(grepl(paste0('(?=.*',as.character(metadata$sample[i]),')'),rownames(corrected), perl=T)) 
}


```

In the list `positions` we know where can we find the corrected mean spectra for each sample identified in `metadata$sample`. For instance, for `metadata$sample[1]`:

```{r}
metadata$sample[1]
```
we have in `positions`, where can we find the spectra for sample 125:

```{r}
rownames(corrected)[positions[[1]]]
```
Now, we can create a new column in metadata, to state which sample has spectra:

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra[i] <- rownames(corrected)[positions[[i]]]
  }else{
    metadata$spectra[i] <- NA
  }
  
}

data.frame(metadata = metadata$sample, spectra = metadata$spectra)
```

Also we can add an index column for when we need to call spectra from `corrected`
Now we know what we have of each sample, as far as composition and spectra are concerned.

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra.index[i] <- positions[[i]]
  }else{
    metadata$spectra.index[i] <- NA
  }
  
}


```

# Leaves selection


prior work indicates that leave samples presented more variability thus it is worth it to subset a table with these samples:

First, we ask `R` where can we find leave samples in metadata:

```{r}
leaves.index <- which(grepl(paste0('(?=.*','L',')'),metadata$class,perl = T))
leaves.index
```
Now that we know, we can separate these samples in a nwe data set

```{r}
metadata.leaves <- metadata[leaves.index,]
metadata.leaves
```

# Silicon quantification

Now, we can delete the rows (samples) that have no spectra, or silicon content.

```{r}
which(is.na(metadata.leaves$Si))
which(is.na(metadata.leaves$spectra))
```
```{r}
metadata.leaves$sample[11]
```
Now we can delete the sample `164`, since it does not have silicon content nor spectra.

```{r}
metadata.leaves.Si <- metadata.leaves[-c(11),]
```

Then, we can extrat the silicon content to a vector called `leavesSi`:

```{r}
LeavesSi <- cbind(metadata.leaves.Si$sample,metadata.leaves.Si$Si)
```

And we can create a table with corrected mean spectra for this samples:

```{r}
leavesSiSpectra <- corrected[metadata.leaves.Si$spectra.index,]

for (i in 1:length(rownames(leavesSiSpectra))){
  
  plot(as.numeric(colnames(leavesSiSpectra)), 
     leavesSiSpectra[i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.06))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')

```

## Silicon concentration

we have to create a `data.frame` in order to use the `plsr` function available in the `pls` package.

```{r}

leavesSiSpectra <- as.matrix(leavesSiSpectra)
SiTable <- data.frame(Si = I(metadata.leaves.Si$Si),spectra = I(leavesSiSpectra) )

```

## model

```{r}
library(pls)
SiPLS <- plsr(SiTable$Si~ leavesSiSpectra, 
              ncomp = 10,
              data = SiTable,
              validation = 'LOO')
```


```{r}
plot(RMSEP(SiPLS),type="b",legendpos="topright")
```



```{r}
plot(SiPLS,ncomp=3,line=TRUE)
```
```{r}
plot(SiPLS,plottype="scores",comps=1:4)
```


```{r}
barplot(explvar(SiPLS)[1:4]) 
```


## Variable selection

```{r}
library(subselect)
Hmat <- lmHmat(leavesSiSpectra,metadata.leaves.Si$Si)
gen <- genetic(Hmat$mat, kmin =4, kmax = 15, H= Hmat$H, r =1, crit = 'CCR12', force = T)
```
  
  
```{r}
colnames(leavesSiSpectra)[gen$bestsets[12,]]

```
# Multiple OLS with new variables 
```{r}
mols <- lm(metadata.leaves.Si$Si ~ leavesSiSpectra[,gen$bestsets[12,]], y = T, x = T)
```

```{r}
#                     
```
```{r}


library(pls)
SiPLSgen <- plsr(SiTable$Si~ leavesSiSpectra[,gen$bestsets[12,]], ncomp = 10,
              data = SiTable,
              validation = 'LOO')


```

```{r}
plot(RMSEP(SiPLSgen),type="b",legendpos="topright")
```


```{r}
plot(SiPLS,ncomp=10,line=TRUE)
```

```{r}
# library(lmvar)
# cv.lm(mols,
#      k = nrow(leav)
#       )
```



## Multivariate analysis



<!-- #class -->

<!-- Now, we can search for the elements of `sample`, in the `mean` matrix: -->

<!-- * First, we extract -->
<!-- ```{r} -->

<!-- class <- unlist((metadata$class)) -->

<!-- which(is.na(class)) -->

<!-- metadata$sample[which(is.na(class))] -->

<!-- metadata2 <- metadata[-c(which(is.na(class))),] -->

<!-- ask<-list(81) -->

<!-- for(i in 1:81){ -->

<!--   ask[[i]] <- which( -->
<!--                    grepl( -->
<!--                           paste0('(?=.*', -->
<!--                                  as.character(metadata$sample)[i], -->
<!--                                  ')' -->
<!--                                  ), -->
<!--                           rownames(mean), -->
<!--                           perl = T -->
<!--                           ) -->
<!--                    ) -->
<!-- } -->
<!-- ask <- unlist(ask) -->
<!-- meta.means <- mean[ask,] -->
<!-- rownames(meta.means) -->
<!-- as.character(metadata$sample) -->
<!-- ``` -->
<!-- SAmples 131 and 159 don't have classification information -->

<!-- ```{r} -->
<!-- ask2 <- list(74) -->

<!-- for(i in 1:74){ -->

<!--   ask2[[i]] <- which( -->
<!--                    grepl( -->
<!--                           paste0('(?=.*', -->
<!--                                  as.character(rownames(meta.means))[i], -->
<!--                                  ')' -->
<!--                                  ), -->
<!--                           metadata$sample, -->
<!--                           perl = T -->
<!--                           ) -->
<!--                    ) -->
<!-- } -->
<!-- ask2 <- unlist(ask2) -->

<!-- metadata.class <- metadata[ask2,] -->
<!-- str(metadata.class$sample) -->
<!-- str(rownames(meta.means)) -->
<!-- compare <- data.frame(means =  rownames(meta.means),class=metadata.class$sample) -->
<!-- compare -->
<!-- ``` -->
<!-- Now, that we can ensure which samples with spectra have classification, we can merge them -->
