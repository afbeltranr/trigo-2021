---
title: "The structure and interaction of silica in plant cell walls: Data analysis report"
author: "Felipe Beltran"
date: "6/16/2021"
output:
    rmdformats::downcute
---

# Introduction

In this document we will save all data manipulation and analysis related to the infrared spectra from the project: **The structure and interaction of silica in plant cell walls**

# Loading data into `R`

```{r}
names <- list.files(pattern = '.CSV')
spectra.list <- lapply(names, read.csv, header = F)
wavenumbers <- unlist(spectra.list[[1]][1])
spectra.list2 <- lapply(spectra.list, '[', 2)
spectra.df <- as.data.frame(t(as.data.frame(spectra.list2)))
rownames(spectra.df) <- names
colnames(spectra.df) <- wavenumbers
# gsub('.{6}$', '', names)
```

# Plotting intial data

```{r}

names2 <- gsub('.{4}$', '', rownames(spectra.df))
names2[292:318] <- gsub('.{41}$', '', rownames(spectra.df)[292:318])
rownames(spectra.df) <- names
cols <- factor(gsub('.{2}$', '', names2))
for(i in  1:length(rownames(spectra.df))){
  
  plot(wavenumbers,
    spectra.df[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(4000, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra full range',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```


# range selection

```{r}
colnames(spectra.df)[c(1,676)]
```
```{r}
range1 <- spectra.df[,c(1:676)]
wavenumbers1 <- wavenumbers[c(1:676)]
for(i in  1:length(rownames(range1))){
  
  plot(wavenumbers1,
    range1[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra - ROI',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')

```
# mean spectra calculation

First, we create a vector to tell R which samples to look for:

```{r}
search.vector <- unique(unlist(cols))
```
Now we search for each triad of samples:

```{r}
index <- list(106)

for (i in 1:106){
  
  index[[i]] <- which(grepl(paste0('(?=.*',as.character(search.vector[i]),')'),
                       rownames(spectra.df),
                       perl=T
                       )
                 )
}
```

Now we can calculate the means:

```{r}
mean <- matrix(ncol= ncol(range1),
               nrow = nrow(range1)/3)
# mean <- as.data.frame(mean)

colnames(mean) <- colnames(range1)
rownames(mean) <- search.vector

for(j in 1:length(colnames(range1))){
  
for(i in 1:length(rownames(mean))){

mean[i,j] <- mean(c(range1[index[[i]][1],j],
                    range1[index[[i]][2],j],
                    range1[index[[i]][3],j]
                      ) )
}
}
mean <- as.data.frame(mean)
```

Now we can plot the means:

```{r}

cols.means <- as.factor(search.vector)
for(i in  1:length(rownames(mean))){
  
  plot(wavenumbers1,
    mean[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols.means[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'averaged spectra',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```



# baseline correction

```{r}
library(hyperSpec)


spc <- new('hyperSpec',
           spc= mean, 
           wavelength = wavenumbers1)

bend <- 0.1 * wl.eval(spc,
                      function (x) x^6+x^5+x^4+x^3+x^2,
                      normalize.wl = normalize01)

bl <- spc.rubberband(spc+bend, noise = 1e-4, df = 20)-bend
suma <- spc+bend
spc3 <- spc - bl

plot(spc, wl.reverse = TRUE)
plot(bl, add=TRUE, col=2,wl.reverse = TRUE)
plot(suma,wl.reverse = TRUE)
plot(bend, add=TRUE, col=2,wl.reverse = TRUE)
plot(spc3,wl.reverse = TRUE)

corrected1  <- as.data.frame(spc3[1:106])
corrected <- as.data.frame(corrected1[,1])
corrected <- corrected + (min(corrected)*-1) # shifting upwards to prevent negative values
```

# multiplicative scatter correction (MSC)
```{r}
library(pls)
correctedMSC <- msc(as.matrix(corrected))



for (i in 1:length(rownames(correctedMSC))){
  
  plot(as.numeric(colnames(correctedMSC)), 
     correctedMSC[i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.06))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')
```

```{r ,echo = FALSE}
# par(mfrow = c(2,2))
# 
# for(i in  1:length(rownames(spectra.df))){
#   
#   plot(wavenumbers,
#     spectra.df[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(4000, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra full range',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(range1))){
#   
#   plot(wavenumbers1,
#     range1[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra - ROI',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     mean[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'averaged spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     corrected[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.1),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'corrected spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')

```


# metadata


First, we load the metadata table, created from the data table 'Datos_para_colombia.xlsx':

```{r}
library(readxl)
metadata <- read_excel("metadata.xlsx")
which(is.na(metadata$sample))
```


```{r}
metadata <- metadata[-c(17),]
which(is.na(metadata$sample))
```

## matching samples that have metadata with samples with spectra

```{r}

positions <- vector('list', 87) # the same sizeas metadata$sample

for (i in 1:87){
  
positions[[i]] <- which(grepl(paste0('(?=.*',as.character(metadata$sample[i]),')'),rownames(corrected), perl=T)) 
}


```

In the list `positions` we know where can we find the corrected mean spectra for each sample identified in `metadata$sample`. For instance, for `metadata$sample[1]`:

```{r}
metadata$sample[1]
```
we have in `positions`, where can we find the spectra for sample 125:

```{r}
rownames(corrected)[positions[[1]]]
```
Now, we can create a new column in metadata, to state which sample has spectra:

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra[i] <- rownames(corrected)[positions[[i]]]
  }else{
    metadata$spectra[i] <- NA
  }
  
}

compare <- data.frame(metadata = metadata$sample, spectra = metadata$spectra)
```

Also we can add an index column for when we need to call spectra from `corrected`
Now we know what we have of each sample, as far as composition and spectra are concerned.

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra.index[i] <- positions[[i]]
  }else{
    metadata$spectra.index[i] <- NA
  }
  
}


```

# Leaves selection


prior work indicates that leave samples presented more variability thus it is worth it to subset a table with these samples:

First, we ask `R` where can we find leave samples in metadata:

```{r}
leaves.index <- which(grepl(paste0('(?=.*','L',')'),metadata$class,perl = T))
leaves.index
```
Now that we know, we can separate these samples in a nwe data set

```{r}
metadata.leaves <- metadata[leaves.index,]
head(metadata.leaves)
```

# Silicon quantification

Now, we can delete the rows (samples) that have no spectra, or silicon content.

```{r}
which(is.na(metadata.leaves$Si))
which(is.na(metadata.leaves$spectra))
```
```{r}
metadata.leaves$sample[11]
```
Now we can delete the sample `164`, since it does not have silicon content nor spectra.

```{r}
metadata.leaves.Si <- metadata.leaves[-c(11),]
```

Then, we can extrat the silicon content to a vector called `leavesSi`:

```{r}
LeavesSi <- cbind(metadata.leaves.Si$sample,metadata.leaves.Si$Si)
```

And we can create a table with corrected mean spectra for this samples:

```{r}
leavesSiSpectra <- corrected[metadata.leaves.Si$spectra.index,]

for (i in 1:length(rownames(leavesSiSpectra))){
  
  plot(as.numeric(colnames(leavesSiSpectra)), 
     leavesSiSpectra[i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.06))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')

```




## Silicon concentration

we have to create a `data.frame` in order to use the `plsr` function available in the `pls` package.

```{r}

leavesSiSpectra <- as.matrix(leavesSiSpectra)
SiTable <- data.frame(Si = I(metadata.leaves.Si$Si),spectra = I(leavesSiSpectra) )
nuevoRango <-   leavesSiSpectra[,c(261:676)]
colnames( leavesSiSpectra[,c(261,676)])
```

## model

```{r}
library(pls)
SiPLS <- plsr(SiTable$Si~ msc(nuevoRango), 
              ncomp = 10,
              data = SiTable,
              validation = 'LOO')
```



```{r}
plot(RMSEP(SiPLS),type="b",legendpos="topright")
```



```{r}
plot(SiPLS,ncomp=4,line=TRUE)
```
```{r}
plot(SiPLS,plottype="scores",comps=1:4)
```


```{r}
barplot(explvar(SiPLS)[1:4]) 
```


## Variable selection

```{r}
library(subselect)
Hmat <- lmHmat(leavesSiSpectra,metadata.leaves.Si$Si)
gen <- genetic(Hmat$mat, kmin =4, kmax = 15, H= Hmat$H, r =1, crit = 'CCR12', force = T)
```
  
as if we inspect the content of the variables selected with:

```{r}
View(leavesSiSpectra[,gen$bestsets[12,]])
```
  

  
```{r}
colnames(leavesSiSpectra)[gen$bestsets[3,]]

```
# Multiple OLS with new variables 

```{r}
mols <- lm(metadata.leaves.Si$Si ~ leavesSiSpectra[,gen$bestsets[3,]], y = T, x = T)
```


```{r}
summary(mols)

```

```{r}
predictions8Var <- predict(mols,  newdata = as.data.frame(leavesSiSpectra[,gen$bestsets[3,]]))
predX8Var <- SiTable$Si
predY8var <- predictions8Var

table8bar <- data.frame(I( predX8Var),I(predY8var))

lm.C <- lm(predX8Var~predY8var)

plot(predX8Var,
	 predY8var,
	 xlab="Si real (ppm)" ,
 	 ylab="Si predicho (ppm)",
 	 pch=17,
 	 cex=1.2,
 	 col="darkorchid4",
 	 cex.lab=1
 	 )
abline(a=-5.856e-10  , b=1, col=1, lty=1, lwd=2)
# legend("topleft", recta.restado, pch=pch ,col=colfin, cex=1)

```
## cross validation for MOLS and selected variables

```{r}
library(DAAG)
SiTablegen <- data.frame(cbind(metadata.leaves.Si$Si,
                    leavesSiSpectra[,gen$bestsets[3,]]))
colnames(SiTablegen)[1] <- 'Si'

SiCVgenmols <-  cv.lm(data = SiTablegen,
                form.lm = formula(Si~.),
                m = 23,
                seed = 1)
```

```{r}
library(lmvar)
cv.lm(mols,
      k=23)

```



## PLS with new variables

```{r}


library(pls)
SiPLSgen <- plsr(SiTable$Si~ leavesSiSpectra[,gen$bestsets[12,]], 
              data = SiTable,
              validation = 'LOO')


```

```{r}
plot(RMSEP(SiPLSgen),type="b",legendpos="topright")
```


```{r}
plot(SiPLS,ncomp=4,line=TRUE)
```

```{r}
par(mfrow=c(3,4))
for(j in 1:nrow(gen$bestsets)){
for (i in 1:length(rownames(leavesSiSpectra))){
plot(as.numeric(colnames(leavesSiSpectra)),
leavesSiSpectra[i,],
xlab = '',
ylab = '',
axes = F,
type = 'l',
xlim = c(1700,400),
ylim = c(0,0.06))
par(new = T)
}
box()
axis(1)
axis(2)
title(main = paste(as.character(c(4:15)[j]),'variables'),
xlab = expression(paste('Wave number (cm'^'-1',')')),
ylab = 'Absorbance (a.u.)')
abline(v = as.numeric(colnames(leavesSiSpectra)[gen$bestsets[j,]]),
col = 2,
lty = 2)
}
```


```{r}
# library(lmvar)
# cv.lm(mols,
#      k = nrow(leav)
#       )
```



## Multivariate analysis

