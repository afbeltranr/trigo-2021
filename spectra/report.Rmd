---
title: "The structure and interaction of silica in plant cell walls: Data analysis report"
author: "Felipe Beltran"
date: "6/16/2021"
output:
    rmdformats::downcute
---

# Introduction

In this document we will save all data manipulation and analysis related to the infrared spectra from the project: **The structure and interaction of silica in plant cell walls**

# Loading data into `R`

```{r }
names <- list.files(pattern = '.CSV')
spectra.list <- lapply(names, read.csv, header = F)
wavenumbers <- unlist(spectra.list[[1]][1])
spectra.list2 <- lapply(spectra.list, '[', 2)
spectra.df <- as.data.frame(t(as.data.frame(spectra.list2)))
rownames(spectra.df) <- names
colnames(spectra.df) <- wavenumbers
# gsub('.{6}$', '', names)
```

# Plotting intial data

```{r }

names2 <- gsub('.{4}$', '', rownames(spectra.df))
names2[292:318] <- gsub('.{41}$', '', rownames(spectra.df)[292:318])
rownames(spectra.df) <- names
cols <- factor(gsub('.{2}$', '', names2))
for(i in  1:length(rownames(spectra.df))){
  
  plot(wavenumbers,
    spectra.df[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(4000, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra full range',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```


# range selection

```{r revision of the column position for }
colnames(spectra.df)[c(1,676)]
```
```{r}
range1 <- spectra.df[,c(1:676)]
wavenumbers1 <- wavenumbers[c(1:676)]
for(i in  1:length(rownames(range1))){
  
  plot(wavenumbers1,
    range1[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra - ROI',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')

```
# mean spectra calculation

First, we create a vector to tell R which samples to look for:

```{r}
search.vector <- unique(unlist(cols))
```
Now we search for each triad of samples:

```{r}
index <- list(106)

for (i in 1:106){
  
  index[[i]] <- which(grepl(paste0('(?=.*',as.character(search.vector[i]),')'),
                       rownames(spectra.df),
                       perl=T
                       )
                 )
}
```

Now we can calculate the means:

```{r}
mean <- matrix(ncol= ncol(range1),
               nrow = nrow(range1)/3)
# mean <- as.data.frame(mean)

colnames(mean) <- colnames(range1)
rownames(mean) <- search.vector

for(j in 1:length(colnames(range1))){
  
for(i in 1:length(rownames(mean))){

mean[i,j] <- mean(c(range1[index[[i]][1],j],
                    range1[index[[i]][2],j],
                    range1[index[[i]][3],j]
                      ) )
}
}
mean <- as.data.frame(mean)
```

Now we can plot the means:

```{r}

cols.means <- as.factor(search.vector)
for(i in  1:length(rownames(mean))){
  
  plot(wavenumbers1,
    mean[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.135309),
    type = 'l',
    col =cols.means[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```



# baseline correction

```{r}
library(hyperSpec)


spc <- new('hyperSpec',
           spc= mean, 
           wavelength = wavenumbers1)

bend <- 0.1 * wl.eval(spc,
                      function (x) x^6+x^5+x^4+x^3+x^2,
                      normalize.wl = normalize01)

bl <- spc.rubberband(spc+bend, noise = 1e-4, df = 20)-bend
suma <- spc+bend
spc3 <- spc - bl
spc3 <- spc3 + (min(spc3)*-1)

labels (spc, ".wavelength") <- expression(paste('Wave number (cm'^'-1',')'))
labels (spc, "spc") <- expression(paste('Absorbance (a.u.)'))

labels (spc3, ".wavelength") <- expression(paste('Wave number (cm'^'-1',')'))
labels (spc3, "spc") <- expression(paste('Absorbance (a.u.)'))
plot(spc, wl.reverse = TRUE)
plot(bl, add=TRUE, col=2,wl.reverse = TRUE)
plot(suma,wl.reverse = TRUE)
plot(bend, add=TRUE, col=2,wl.reverse = TRUE)
plot(spc3,wl.reverse = TRUE)

corrected1  <- as.data.frame(spc3[1:106])
corrected <- as.data.frame(corrected1[,1])
corrected <- corrected + (min(corrected)*-1) # shifting upwards to prevent negative values
```

# multiplicative scatter correction (MSCF)
```{r}
library(pls)
correctedMSC <- msc(as.matrix(corrected))



for (i in 1:length(rownames(correctedMSC))){
  
  plot(as.numeric(colnames(correctedMSC)), 
     correctedMSC[i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.06))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')
```

```{r ,echo = FALSE}
# par(mfrow = c(2,2))
# 
# for(i in  1:length(rownames(spectra.df))){
#   
#   plot(wavenumbers,
#     spectra.df[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(4000, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra full range',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(range1))){
#   
#   plot(wavenumbers1,
#     range1[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra - ROI',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     mean[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'averaged spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     corrected[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.1),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'corrected spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')

```


# metadata


First, we load the metadata table, created from the data table 'Datos_para_colombia.xlsx':

```{r}
library(readxl)
metadata <- read_excel("metadata.xlsx")
which(is.na(metadata$sample))
```


```{r}
metadata <- metadata[-c(17),]
which(is.na(metadata$sample))
```

## matching samples that have metadata with samples with spectra

```{r}

positions <- vector('list', 87) # the same sizeas metadata$sample

for (i in 1:87){
  
positions[[i]] <- which(grepl(paste0('(?=.*',as.character(metadata$sample[i]),')'),rownames(corrected), perl=T)) 
}


```

In the list `positions` we know where can we find the corrected mean spectra for each sample identified in `metadata$sample`. For instance, for `metadata$sample[1]`:

```{r}
metadata$sample[1]
```
we have in `positions`, where can we find the spectra for sample 125:

```{r}
rownames(corrected)[positions[[1]]]
```
Now, we can create a new column in metadata, to state which sample has spectra:

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra[i] <- rownames(corrected)[positions[[i]]]
  }else{
    metadata$spectra[i] <- NA
  }
  
}

compare <- data.frame(metadata = metadata$sample, spectra = metadata$spectra)
```

Also we can add an index column for when we need to call spectra from `corrected`
Now we know what we have of each sample, as far as composition and spectra are concerned.

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra.index[i] <- positions[[i]]
  }else{
    metadata$spectra.index[i] <- NA
  }
  
}
```

# Leaves selection
## Selection of samples

prior work indicates that leave samples presented more variability thus it is worth it to subset a table with these samples:

First, we ask `R` where can we find leave samples in metadata:

```{r}
leaves.index <- which(grepl(paste0('(?=.*','L',')'),metadata$class,perl = T))
leaves.index
```
Now that we know, we can separate these samples in a new  data set

```{r}
metadata.leaves <- metadata[leaves.index,]
head(metadata.leaves)
```


## Silicon quantification in leaves samples

Now, we can delete the rows (samples) that have no spectra, or silicon content.

```{r}
which(is.na(metadata.leaves$Si))
which(is.na(metadata.leaves$spectra))
```
```{r}
metadata.leaves$sample[11]
```
Now we can delete the sample `164`, since it does not have silicon content nor spectra.

```{r}
metadata.leaves.Si <- metadata.leaves[-c(11),]
```

Then, we can extrat the silicon content to a vector called `leavesSi`:

```{r}
LeavesSi <- cbind(metadata.leaves.Si$sample,metadata.leaves.Si$Si)
```

And we can create a table with corrected mean spectra for this samples:

```{r}

win.graph()
leavesSiSpectra <- corrected[metadata.leaves.Si$spectra.index,]
leavesSiSpectraRaw <- mean[metadata.leaves.Si$spectra.index,] 

par(mfrow = c(1,2))

for (i in 1:length(rownames(leavesSiSpectraRaw ))){
  
  plot(as.numeric(colnames(leavesSiSpectraRaw )), 
     leavesSiSpectraRaw [i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.1))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')

par(new = F)

for (i in 1:length(rownames(leavesSiSpectra))){
  
  plot(as.numeric(colnames(leavesSiSpectra)), 
     leavesSiSpectra[i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.1))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')

```


## Covariance matrix


```{r}

library(colorRamps)
library(colorspace)
library(viridis)
corleaves <- cov(leavesSiSpectra)

image(as.numeric(colnames(leavesSiSpectra)),
	   as.numeric(colnames(leavesSiSpectra)),
	  corleaves,
	  col=viridis(100),
	  axes=FALSE,
	  xlab="",
	  ylab="",
	  xlim=c(1700,400),
	   ylim=c(1700,400))
contour(as.numeric(colnames(leavesSiSpectra)),
	    as.numeric(colnames(leavesSiSpectra)),
	    corleaves,
	    add=TRUE,
	    col="black",
	    xlab="",
	    ylab="",
	    labcex=1.1,
	    ylim=c(1700,400),
	    labels=""
	)
contour(as.numeric(colnames(leavesSiSpectra)),
	     as.numeric(colnames(leavesSiSpectra)),
	    corleaves,
	    lty=0,
	    labcex=1.3,
	    add=TRUE,
	    col="black",
	    vfont=c("sans serif", "bold italic"),
	    nlevels=2
	)

axis(1)
axis(2)
box()
```


## Silicon concentration

we have to create a `data.frame` in order to use the `plsr` function available in the `pls` package.

```{r}

leavesSiSpectra <- as.matrix(leavesSiSpectra)
SiTable <- data.frame(Si = I(metadata.leaves.Si$Si),spectra = I(leavesSiSpectra) )
nuevoRango <-   leavesSiSpectra[,c(261:676)]
colnames( leavesSiSpectra[,c(261,676)])
```

## model

```{r}
library(pls)
SiPLS <- plsr(SiTable$Si~ msc(nuevoRango), 
              ncomp = 10,
              data = SiTable,
              validation = 'LOO')
```



```{r}
plot(RMSEP(SiPLS),type="b",legendpos="topright")
```



```{r}
plot(SiPLS,ncomp=4,line=TRUE)
```
```{r}
plot(SiPLS,plottype="scores",comps=1:4)
```


```{r}
barplot(explvar(SiPLS)[1:4]) 
```


## Variable selection

```{r}
library(subselect)
Hmat <- lmHmat(leavesSiSpectra,metadata.leaves.Si$Si)
gen <- genetic(Hmat$mat, kmin =4, kmax = 12, H= Hmat$H, r =1, crit = 'CCR12', force = T)
```

  
  

```{r}
win.graph()
par(mfrow=c(3,3))
for(j in 1:nrow(gen$bestsets)){
for (i in 1:length(rownames(leavesSiSpectra))){
plot(as.numeric(colnames(leavesSiSpectra)),
leavesSiSpectra[i,],
xlab = '',
ylab = '',
axes = F,
type = 'l',
xlim = c(1700,400),
ylim = c(0,0.06))
par(new = T)
}
box()
axis(1)
axis(2)
title(main = paste(as.character(c(4:15)[j]),'variables'),
xlab = expression(paste('Wave number (cm'^'-1',')')),
ylab = 'Absorbance (a.u.)')
abline(v = as.numeric(colnames(leavesSiSpectra)[gen$bestsets[j,]]),
col = 2,
lty = 2)
}
```  
  

# Multiple OLS with new variables 

We can try and predict the silicon content in each sample using each of the models created by using que X matrix as the selected frequencies by the genetic algorithm:

```{r}
listOfPredictions1 <- vector('list', length = nrow(gen$bestsets))

listOfModels1 <- vector('list', length = nrow(gen$bestsets)) 
```


```{r}

for(i in 1:nrow(gen$bestsets)){

  
  listOfModels1[[i]] <- lm(metadata.leaves.Si$Si ~ leavesSiSpectra[,gen$bestsets[i,]], y = T, x = T)
  
}
```


```{r}


for(i in 1:nrow(gen$bestsets)){

  
  listOfPredictions1[[i]] <- predict(listOfModels1[[i]],  newdata = as.data.frame(leavesSiSpectra[,gen$bestsets[i,]]))
  
}
```



```{r}

for(i in 1:nrow(gen$bestsets)){

  
  listOfPredictions1[[i]] <- predict(listOfModels1[[i]],  newdata = as.data.frame(leavesSiSpectra[,gen$bestsets[i,]]))
  
}
```


```{r}
par(mfrow = c(3,3))
for(i in 1:nrow(gen$bestsets)){
plot(predX8Var,
	 listOfPredictions1[[i]],
	 xlab="Actual Si (ppm)" ,
 	 ylab="Predicted Si (ppm)",
 	 pch=17,
 	 cex=1.2,
 	 col="darkorchid4",
 	 cex.lab=1
 	 )
abline(a=0  , b=1, col=1, lty=1, lwd=2)
}
```


```{r}
summary(mols)
```

```{r}
predictions8Var <- predict(mols,  newdata = as.data.frame(leavesSiSpectra[,gen$bestsets[4,]]))
 n
predY8var <- predictions8Var

table8bar <- data.frame(I( predX8Var),I(predY8var))

lm.C <- lm(predX8Var~predY8var)

plot(predX8Var,
	 predY8var,
	 xlab="Actual Si (ppm)" ,
 	 ylab="Predicted Si (ppm)",
 	 pch=17,
 	 cex=1.2,
 	 col="darkorchid4",
 	 cex.lab=1
 	 )
abline(a=0  , b=1, col=1, lty=1, lwd=2)
# legend("topleft", recta.restado, pch=pch ,col=colfin, cex=1)

```
## cross validation for MOLS and selected variables




```{r}
library(tidyverse)
library(caret)

# First we create a list of tables with the best subsets selected by the genetic algorithm

listOfTables <- vector('list', nrow(gen$bestsets))

listOfModels <- vector('list', nrow(gen$bestsets))

listOfRMSEP <- vector('list', nrow(gen$bestsets))

system.time(
for(i in 1:nrow(gen$bestsets)){
  
 listOfTables[[i]] <- cbind(Si  = metadata.leaves.Si$Si, as.data.frame(leavesSiSpectra[,gen$bestsets[i,]]))
  
 
 # setting seed to generate a
# reproducible random sampling
set.seed(125)
 
# defining training control as
# repeated cross-validation and
# value of K is 10 and repetition is 100 times

train_control <- trainControl(method = "repeatedcv",
                            number = 10, repeats = 100)
 
# training the model by assigning sales column
# as target variable and rest other column
# as independent variable

listOfModels[[i]] <- train(Si ~., 
                       data = listOfTables[[i]],
                       method = "lm",
                      trControl = train_control)


listOfRMSEP[[i]] <- listOfModels[[i]]$resample$RMSE
 
}

)
  
RMSEP <- c(listOfRMSEP[[1]],listOfRMSEP[[2]],listOfRMSEP[[3]],listOfRMSEP[[4]],listOfRMSEP[[5]],listOfRMSEP[[6]],listOfRMSEP[[7]],listOfRMSEP[[8]],listOfRMSEP[[9]])



RMSEPTable <- data.frame(RMSEP = RMSEP, variables = c(rep(4,1000),rep(5,1000),rep(6,1000),rep(7,1000),rep(8,1000),rep(9,1000),rep(10,1000),rep(11,1000),rep(12,1000)))

RMSEPTable$variables <- as.factor(RMSEPTable$variables)


# # R program to implement
# # repeated K-fold cross-validation
#  
# # setting seed to generate a
# # reproducible random sampling
# set.seed(125)
#  
# # defining training control as
# # repeated cross-validation and
# # value of K is 10 and repetation is 3 times
# train_control <- trainControl(method = "repeatedcv",
#                             number = 10, repeats = 3)
#  
# # training the model by assigning sales column
# # as target variable and rest other column
# # as independent variable
# model <- train(Si ~., data = marketing,
#                method = "lm",
#                trControl = train_control)
#  
# # printing model performance metrics
# # along with other details
# print(model)
```



```{r cross validation graph}


dp <- ggplot(RMSEPTable, aes(x=variables, y=RMSEP, fill=variables)) + 
  geom_violin(trim=FALSE)+
  geom_boxplot(width=0.1, fill='white')+
  labs(title="CVRMSE vs # of variables ",x="# of variables selected", y = "RMSE (n = 1000)")
dp + scale_fill_brewer(palette="Blues") + theme_minimal()



```

# NIST Apple Leaves Reference material infrared spectra




## Importing data

```{r}
namesNIST <- list.files(path = "./AppleLeaves",pattern = '.CSV')
spectra.listNIST <- lapply(paste0('./AppleLeaves/',namesNIST), read.csv, header = F)
wavenumbersNIST <- unlist(spectra.listNIST[[1]][1])
spectra.list2NIST <- lapply(spectra.listNIST, '[', 2)
spectra.dfNIST <- as.data.frame(t(as.data.frame(spectra.list2NIST)))
rownames(spectra.dfNIST) <- namesNIST
colnames(spectra.dfNIST) <- wavenumbersNIST


 
```


## plotting initial data for NIST samples

```{r}
for(i in  1:length(rownames(spectra.dfNIST))){
  
  plot(wavenumbersNIST,
    spectra.dfNIST[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(4000, 400),
    ylim= c(0,0.2),
    type = 'l',
    col ='black'

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra full range',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```

## range selection for NIST samples

```{r}
colnames(spectra.df)[c(1,676)]
```
```{r}
range1NIST <- spectra.dfNIST[,c(1:676)]
wavenumbers1NIST <- wavenumbersNIST[c(1:676)]
for(i in  1:length(rownames(range1NIST))){
  
  plot(wavenumbers1NIST,
    range1NIST[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.1),
    type = 'l',
    col ="black"

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra - ROI',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```

# baseline correction for NIST samples


```{r}
library(hyperSpec)


spcNIST <- new('hyperSpec',
           spc= range1NIST, 
           wavelength = wavenumbers1NIST)

bendNIST <- 0.1 * wl.eval(spcNIST,
                      function (x) x^6+x^5+x^4+x^3+x^2,
                      normalize.wl = normalize01)

blNIST <- spc.rubberband(spcNIST+bendNIST, noise = 1e-4, df = 20)-bendNIST
sumaNIST <- spcNIST+bendNIST
spc3NIST <- spcNIST - blNIST

plot(spcNIST, wl.reverse = TRUE)
plot(blNIST, add=TRUE, col=2,wl.reverse = TRUE)
plot(sumaNIST,wl.reverse = TRUE)
plot(bendNIST, add=TRUE, col=2,wl.reverse = TRUE)
plot(spc3NIST,wl.reverse = TRUE)

corrected1NIST  <- as.data.frame(spc3NIST[1:5])
correctedNIST <- as.data.frame(corrected1NIST[,1])
correctedNIST <- correctedNIST + (min(correctedNIST)*-1) # shifting upwards to prevent negative values
```

# prediction of Si content using MOLS with variables selected by genetic algorithms

```{r}

listOfNISTPredictions <- vector('list', length = length(listOfModels))
for(i in 1:length(listOfModels)){
  
 listOfNISTPredictions[[i]] <- predict(listOfModels[[i]], newdata = as.data.frame(correctedNIST[,gen$bestsets[i,]])) 
  
}
```

In the list called `listOfNISTPredictions` we have the prediction fo Si content for each NIST sample. If whe reference value is 400 mg/Kg. we can calculate a relative error:

```{r}

listOfNISTErrors <- vector('list', length = length(listOfModels))
for(i in 1:length(listOfNISTPredictions))
listOfNISTErrors[[i]] <- (abs(listOfNISTPredictions[[i]]-400)/400)*100
```


## PLS with new variables

```{r}


library(pls)
SiPLSgen <- plsr(SiTable$Si~ leavesSiSpectra[,gen$bestsets[3,]], 
              data = SiTable,
              validation = 'LOO')


```

```{r}
plot(RMSEP(SiPLSgen),type="b",legendpos="topright")
```


```{r}
plot(SiPLS,ncomp=4,line=TRUE)
```









# Predicting silicon in other tissues
## wheat straw

### Sample selection

First, we ask R where can we find straw samples in `metadata`

```{r}
straw.index <- which(grepl(paste0('(?=.*','S',')'),metadata$class,perl = T))
straw.index
```

Now that we know where these samples are, we can separate these samples in a new  data set:

```{r}
metadata.straw <- metadata[straw.index,]
head(metadata.straw)
```

### preparing for quantification - deleting samples that have `NA` for spectra index

Here we will ask for which samples have no spectra, or silicon content.

```{r}
which(is.na(metadata.straw$Si))
which(is.na(metadata.straw$spectra))
```
In the row `11`, we have a `NA` for spectra *and* for silicon content. for samples: `19`, `20`, `21` and `22` Let us inspect which samples are in these rows:

```{r}
metadata.straw$sample[c(11,19,20,21,22)]
```

In order to not lose information for other analyses, we can create a new object called `metadata.strawSi` without these samples:


```{r}
metadataStrawSi <- metadata.straw[-c(11,19,20,21,22),]
```

We can create a subset table with corrected mean spectra for straw samples:

```{r}
StrawSiSpectra <- corrected[metadataStrawSi$spectra.index,]

for (i in 1:length(rownames(StrawSiSpectra))){
  
  plot(as.numeric(colnames(StrawSiSpectra)), 
     StrawSiSpectra[i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.06))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')

```


### quantification using each of the models built with leaves data

pendiente, hacer matriz de correlacion con los espectros de hojas que se usaron para construir los modelos, para ver lignina - silica

```{r}
listOfStrawPredictions <-  vector('list', length = length(listOfModels))

for(i in 1:length(listOfModels)){
  
 listOfStrawPredictions[[i]] <- predict(listOfModels[[i]], newdata = as.data.frame(StrawSiSpectra[,gen$bestsets[i,]])) 
  
}
```

In the list called `listOfStrawPredictions` we have the prediction for Si content for each straw sample. We can calculate the difference between each of these values and the values present at `metadataStrawSi$Si`, for each model:

```{r}
listOfStrawErrors <- vector('list', length = length(listOfModels))
for(i in 1:length(listOfStrawErrors)){
  
listOfStrawErrors[[i]] <- (abs(listOfStrawPredictions[[i]]-metadataStrawSi$Si)/metadataStrawSi$Si)*100

}
```

we can assess the distribution of errors as follows:

```{r}
# First, we have a list. we have to convert this list to a data.frame. with one column of errors and one column of model identifier:

vectorOfStrawErrors <- unlist(listOfStrawErrors)


StrawErrorsdf <- data.frame(error = vectorOfStrawErrors, model= as.factor(rep(4:12,each =20)))

dp <- ggplot(StrawErrorsdf, aes(x= model, y=error, fill=model)) + 
  geom_violin(trim=FALSE)+
  geom_boxplot(width=0.1, fill='white')+
  labs(title="error of prediction for straw samples",x="# of variables selected", y = "relative error (n=20)")
dp + scale_fill_brewer(palette="Blues") + theme_minimal() + geom_hline(yintercept=100) 

```




## wheat roots

### Sample selection

First, we ask R where can we find roots samples in `metadata`

```{r}
Roots.index <- which(grepl(paste0('(?=.*','R',')'),metadata$class,perl = T))
Roots.index
```

Now that we know where these samples are, we can separate these samples in a new  data set:

```{r}
metadata.Roots <- metadata[Roots.index,]
head(metadata.Roots)
```

### preparing for quantification - deleting samples that have `NA` for spectra index

Here we will ask for which samples have no spectra, or silicon content.

```{r}
which(is.na(metadata.Roots$Si))
which(is.na(metadata.Roots$spectra))
```
In the row `11`, we have a `NA` for spectra *and* for silicon content. for samples: `19`, `20`, `21` and `22` Let us inspect which samples are in these rows:

```{r}
metadata.Roots$sample[c(6,8)]
```

In order to not lose information for other analyses, we can create a new object called `metadataRootsSi` without these samples:


```{r}
metadataRootsSi <- metadata.Roots[-c(6,8),]
```

We can create a subset table with corrected mean spectra for Roots samples:

```{r}
RootsSiSpectra <- corrected[metadataRootsSi$spectra.index,]

for (i in 1:length(rownames(RootsSiSpectra))){
  
  plot(as.numeric(colnames(RootsSiSpectra)), 
     RootsSiSpectra[i,],
     xlab = '',
     ylab = '',
     axes = F,
     type = 'l',
     xlim = c(1700,400),
     ylim = c(0,0.06))
  par(new = T)
}
box()
axis(1)
axis(2)
title(main = '',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab = 'Absorbance (a.u.)')

```


### quantification using each of the models built with leaves data

```{r}
listOfRootsPredictions <-  vector('list', length = length(listOfModels))

for(i in 1:length(listOfModels)){
  
 listOfRootsPredictions[[i]] <- predict(listOfModels[[i]], newdata = as.data.frame(RootsSiSpectra)) 
  
}
```

In the list called `listOfRootsPredictions` we have the prediction for Si content for each Roots sample. We can calculate the difference between each of these values and the values present at `metadataRootsSi$Si`, for each model:

```{r}
listOfRootsErrors <- vector('list', length = length(listOfModels))
for(i in 1:length(listOfRootsErrors)){
  
listOfRootsErrors[[i]] <- (abs(listOfRootsPredictions[[i]]-metadataRootsSi$Si)/metadataRootsSi$Si)*100

}
```

we can assess the distribution of errors as follows:

```{r}
# First, we have a list. we have to convert this list to a data.frame. with one column of errors and one column of model identifier:

vectorOfRootsErrors <- unlist(listOfRootsErrors)


RootsErrorsdf <- data.frame(error = vectorOfRootsErrors, model= as.factor(rep(4:12,each = 16)))

dp <- ggplot(RootsErrorsdf, aes(x= model, y=error, fill=model)) + 
  geom_violin(trim=FALSE)+
  geom_boxplot(width=0.1, fill='white')+
  labs(title="error of prediction for Roots samples",x="# of variables selected", y = "relative error (n=20)")
dp + scale_fill_brewer(palette="Blues") + theme_minimal() + geom_hline(yintercept=100) 

```




# zero with ludox silica

## Importing data

```{r}
namesludox <- list.files(path = "./AppleLeaves",pattern = '.CSV')
spectra.listludox <- lapply(paste0('./AppleLeaves/',namesludox), read.csv, header = F)
wavenumbersludox <- unlist(spectra.listludox[[1]][1])
spectra.list2ludox <- lapply(spectra.listludox, '[', 2)
spectra.dfludox <- as.data.frame(t(as.data.frame(spectra.list2ludox)))
rownames(spectra.dfludox) <- namesludox
colnames(spectra.dfludox) <- wavenumbersludox
```

## plotting initial data for ludox samples

```{r}
for(i in  1:length(rownames(spectra.dfludox))){
  
  plot(wavenumbersludox,
    spectra.dfludox[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(4000, 400),
    ylim= c(0,0.2),
    type = 'l',
    col ='black'

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra full range',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```


## range selection for ludox samples

```{r}
colnames(spectra.df)[c(1,676)]
```
```{r}
range1ludox <- spectra.dfludox[,c(1:676)]
wavenumbers1ludox <- wavenumbersludox[c(1:676)]
for(i in  1:length(rownames(range1ludox))){
  
  plot(wavenumbers1ludox,
    range1ludox[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.1),
    type = 'l',
    col ="black"

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra - ROI',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```



# baseline correction for ludox samples


```{r}
library(hyperSpec)


spcludox <- new('hyperSpec',
           spc= range1ludox, 
           wavelength = wavenumbers1ludox)

bendludox <- 0.1 * wl.eval(spcludox,
                      function (x) x^6+x^5+x^4+x^3+x^2,
                      normalize.wl = normalize01)

blludox <- spc.rubberband(spcludox+bendludox, noise = 1e-4, df = 20)-bendludox
sumaludox <- spcludox+bendludox
spc3ludox <- spcludox - blludox

plot(spcludox, wl.reverse = TRUE)
plot(blludox, add=TRUE, col=2,wl.reverse = TRUE)
plot(sumaludox,wl.reverse = TRUE)
plot(bendludox, add=TRUE, col=2,wl.reverse = TRUE)
plot(spc3ludox,wl.reverse = TRUE)

corrected1ludox  <- as.data.frame(spc3ludox[1:5])
correctedludox <- as.data.frame(corrected1ludox[,1])
correctedludox <- correctedludox + (min(correctedludox)*-1) # shifting upwards to prevent negative values
```



# Classification

In order to use classification algorithms, we can create a new dataset without missing values in `metadata$spectra`, `metadata$class`, and `metadata$Si` 

```{r}
which(is.na(metadata$spectra))
```
```{r}
which(is.na(metadata$class))
```
```{r}
which(is.na(metadata$Si))
```

```{r}
unique(
          c( which(is.na(metadata$spectra)),
             which(is.na(metadata$class)),
             which(is.na(metadata$Si)))
       )

missing <- unique(
          c( which(is.na(metadata$spectra)),
             which(is.na(metadata$class)),
             which(is.na(metadata$Si)))
       )
```

```{r}
metadata.class <- metadata[-missing,]
```

## Hierarchical clustering and k-means


