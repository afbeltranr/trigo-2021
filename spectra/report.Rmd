---
title: "The structure and interaction of silica in plant cell walls: Data analysis report"
author: "Felipe Beltran"
date: "6/16/2021"
output:
    rmdformats::downcute
---

# Introduction

In this document we will save all data manipulation and analysis related to the infrared spectra from the project: **The structure and interaction of silica in plant cell walls**

# Loading data into `R`

```{r}
names <- list.files(pattern = '.CSV')
spectra.list <- lapply(names, read.csv, header = F)
wavenumbers <- unlist(spectra.list[[1]][1])
spectra.list2 <- lapply(spectra.list, '[', 2)
spectra.df <- as.data.frame(t(as.data.frame(spectra.list2)))
rownames(spectra.df) <- names
colnames(spectra.df) <- wavenumbers
# gsub('.{6}$', '', names)
```

# Plotting intial data

```{r}

names2 <- gsub('.{4}$', '', rownames(spectra.df))
names2[292:318] <- gsub('.{41}$', '', rownames(spectra.df)[292:318])
rownames(spectra.df) <- names
cols <- factor(gsub('.{2}$', '', names2))
for(i in  1:length(rownames(spectra.df))){
  
  plot(wavenumbers,
    spectra.df[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(4000, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra full range',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```


# range selection

```{r}
colnames(spectra.df)[c(1,676)]
```
```{r}
range1 <- spectra.df[,c(1:676)]
wavenumbers1 <- wavenumbers[c(1:676)]
for(i in  1:length(rownames(range1))){
  
  plot(wavenumbers1,
    range1[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'raw spectra - ROI',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')

```
# mean spectra calculation

First, we create a vector to tell R which samples to look for:

```{r}
search.vector <- unique(unlist(cols))
```
Now we search for each triad of samples:

```{r}
index <- list(106)

for (i in 1:106){
  
  index[[i]] <- which(grepl(paste0('(?=.*',as.character(search.vector[i]),')'),
                       rownames(spectra.df),
                       perl=T
                       )
                 )
}
```

Now we can calculate the means:

```{r}
mean <- matrix(ncol= ncol(range1),
               nrow = nrow(range1)/3)
# mean <- as.data.frame(mean)

colnames(mean) <- colnames(range1)
rownames(mean) <- search.vector

for(j in 1:length(colnames(range1))){
  
for(i in 1:length(rownames(mean))){

mean[i,j] <- mean(c(range1[index[[i]][1],j],
                    range1[index[[i]][2],j],
                    range1[index[[i]][3],j]
                      ) )
}
}
mean <- as.data.frame(mean)
```

Now we can plot the means:

```{r}

cols.means <- as.factor(search.vector)
for(i in  1:length(rownames(mean))){
  
  plot(wavenumbers1,
    mean[i,],
    axes = F,
    xlab = '', 
    ylab = '',
    xlim = c(1700, 400),
    ylim= c(0,0.2),
    type = 'l',
    col =cols.means[i]

  )
  par(new = T)
}

box()
axis(1)
axis(2)
title(main = 'averaged spectra',
      xlab = expression(paste('Wave number (cm'^'-1',')')),
      ylab ='absorbance (a.u.)')
```



# baseline correction

```{r}
library(hyperSpec)

spc <- new('hyperSpec',
           spc= mean, 
           wavelength = wavenumbers1)

bend <- 0.1 * wl.eval(spc,
                      function (x) x^6+x^5+x^4+x^3+x^2,
                      normalize.wl = normalize01)

bl <- spc.rubberband(spc+bend, noise = 1e-4, df = 20)-bend
suma <- spc+bend
spc3 <- spc - bl

plot(spc, wl.reverse = TRUE)
plot(bl, add=TRUE, col=2,wl.reverse = TRUE)
plot(suma,wl.reverse = TRUE)
plot(bend, add=TRUE, col=2,wl.reverse = TRUE)
plot(spc3,wl.reverse = TRUE)

corrected1  <- as.data.frame(spc3[1:106])
corrected <- as.data.frame(corrected1[,1])
```

```{r ,echo = FALSE}
# par(mfrow = c(2,2))
# 
# for(i in  1:length(rownames(spectra.df))){
#   
#   plot(wavenumbers,
#     spectra.df[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(4000, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra full range',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(range1))){
#   
#   plot(wavenumbers1,
#     range1[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'raw spectra - ROI',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     mean[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.2),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'averaged spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')
# 
# for(i in  1:length(rownames(mean))){
#   
#   plot(wavenumbers1,
#     corrected[i,],
#     axes = F,
#     xlab = '', 
#     ylab = '',
#     xlim = c(1700, 400),
#     ylim= c(0,0.1),
#     type = 'l',
#     col =cols.means[i]
# 
#   )
#   par(new = T)
# }
# 
# box()
# axis(1)
# axis(2)
# title(main = 'corrected spectra',
#       xlab = expression(paste('Wave number (cm'^'-1',')')),
#       ylab ='absorbance (a.u.)')

```


# metadata


First, we load the metadata table, created from the data table 'Datos_para_colombia.xlsx':

```{r}
library(readxl)
metadata <- read_excel("metadata.xlsx")
which(is.na(metadata$sample))
```


```{r}
metadata <- metadata[-c(17),]
which(is.na(metadata$sample))
```

# matching samples with metadata with samples with spectra

```{r}

positions <- vector('list', 87) # the same sizeas metadata$sample

for (i in 1:87){
  
positions[[i]] <- which(grepl(paste0('(?=.*',as.character(metadata$sample[i]),')'),rownames(corrected), perl=T)) 
}


```

In the list `positions` we know where can we find the corrected mean spectra for each sample identified in `metadata$sample`. For instance, for `metadata$sample[1]`:

```{r}
metadata$sample[1]
```
we have in `positions`, where can we find the spectra for sample 125:

```{r}
rownames(corrected)[positions[[1]]]
```
Now, we can create a new column in metadata, to state which sample has spectra:

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra[i] <- rownames(corrected)[positions[[i]]]
  }else{
    metadata$spectra[i] <- NA
  }
  
}

data.frame(metadata = metadata$sample, spectra = metadata$spectra)
```

Also we can add an index column for when we need to call spectra from `corrected`
Now we know what we have of each sample, as far as composition and spectra are concerned.

```{r}
for(i in 1:length(metadata$sample)) {
  
  if(length(positions[[i]]) == 1){
    
    metadata$spectra.index[i] <- positions[[i]]
  }else{
    metadata$spectra.index[i] <- NA
  }
  
}


```

# Leaves selection








Then we subset the column of samples names, so we can check if these samples with info of classification and Si content have spectra:

```{r}
sample <- unlist(na.omit(metadata$sample))
sample <- as.character(sample)
```

Now we found previously that samples 131,149,161,164, and 167 don't have spectra, we can certify this searching for them:

* Creating an object with the query elements : `search1`
* creating a `list` called `index1` within which we will save *where* in the `mean` matrix can we find the elements of `search1`.

```{r}
search1 <- as.character(c(131,149,161,164,167))
index1 <- list(5)
```

Once we have created the query object and the response object, we can perform the search using a `for` loop, 
```{r}

for(i in 1:5){
  index1[[i]] <- which(grepl(paste0('(?=.*',search1[i],')'),rownames(mean),perl = T))
}

index1
```
here, the function `which` tells us that for each element of the query `search1` how many matches we can find in `rownames(mean)`. The result `integer(0)` means that none of the elements of `search1` can be found in `rouwnames(mean)` in each iteration, hence, there are no spectra for these samples, so we can delete them for now.


```{r}
delete.index1 <- list(5)
for(i in 1:5){
  
  delete.index1[i] <- which(sample == search1[i])
}
delete.index1 <- unlist(delete.index1)
delete.index1

sample2 <- sample[-c(delete.index1)]
metadata2 <- metadata[-c(delete.index1),]
```


Also, we found samples 214 and 216 don't have classification information:

```{r}
which(rownames(mean) == '214' |rownames(mean) == '216')

```
So we can delete them for now:

```{r}
mean2 <- mean[-c(74,75),]
```

Now we can compare:

```{r}
print(rownames(mean2)[-c(96:105)])# We remove protobind
print(sample)
```


prior work indicates that leave samples presented more variability thus it is worth it to subset a table with these samples:

First, we ask `R` where can we find leave samples in metadata:

```{r}
leaves.index <- which(grepl(paste0('(?=.*','L',')'),metadata$class,perl = T))
leaves.index
```
Now that we know, we can separate these samples in a nwe data set

```{r}
metadata.leaves <- metadata[leaves.index,]
metadata.leaves
```

Now, we can delete the rows (samples) that have no spectra, or silicon content.

```{r}

```



<!-- #class -->

<!-- Now, we can search for the elements of `sample`, in the `mean` matrix: -->

<!-- * First, we extract -->
<!-- ```{r} -->

<!-- class <- unlist((metadata$class)) -->

<!-- which(is.na(class)) -->

<!-- metadata$sample[which(is.na(class))] -->

<!-- metadata2 <- metadata[-c(which(is.na(class))),] -->

<!-- ask<-list(81) -->

<!-- for(i in 1:81){ -->

<!--   ask[[i]] <- which( -->
<!--                    grepl( -->
<!--                           paste0('(?=.*', -->
<!--                                  as.character(metadata$sample)[i], -->
<!--                                  ')' -->
<!--                                  ), -->
<!--                           rownames(mean), -->
<!--                           perl = T -->
<!--                           ) -->
<!--                    ) -->
<!-- } -->
<!-- ask <- unlist(ask) -->
<!-- meta.means <- mean[ask,] -->
<!-- rownames(meta.means) -->
<!-- as.character(metadata$sample) -->
<!-- ``` -->
<!-- SAmples 131 and 159 don't have classification information -->

<!-- ```{r} -->
<!-- ask2 <- list(74) -->

<!-- for(i in 1:74){ -->

<!--   ask2[[i]] <- which( -->
<!--                    grepl( -->
<!--                           paste0('(?=.*', -->
<!--                                  as.character(rownames(meta.means))[i], -->
<!--                                  ')' -->
<!--                                  ), -->
<!--                           metadata$sample, -->
<!--                           perl = T -->
<!--                           ) -->
<!--                    ) -->
<!-- } -->
<!-- ask2 <- unlist(ask2) -->

<!-- metadata.class <- metadata[ask2,] -->
<!-- str(metadata.class$sample) -->
<!-- str(rownames(meta.means)) -->
<!-- compare <- data.frame(means =  rownames(meta.means),class=metadata.class$sample) -->
<!-- compare -->
<!-- ``` -->
<!-- Now, that we can ensure which samples with spectra have classification, we can merge them -->
